// Generated by CoffeeScript 1.3.3

/*
Eim v0.1
github.com/rafbgarcia/eimjs.git

Dependencies: jQuery 1.8.2
*/


(function() {

  (function(window) {
    var Eim, Form;
    Eim = {};
    Eim.Form = function(params) {
      return new Form(params);
    };
    Eim.validators = {
      required: function(errMessage) {
        return {
          isValid: function(val) {
            return !!val.toString().trim();
          },
          errMessage: errMessage || 'Field is required'
        };
      },
      email: function(errMessage) {
        var regex;
        regex = /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/;
        return {
          isValid: function(val) {
            if (val && regex.test(val)) {
              return true;
            }
            return false;
          },
          errMessage: errMessage || 'Email is invalid'
        };
      },
      minLength: function(length, errMessage) {
        return {
          isValid: function(val) {
            return val.toString().trim().length >= length;
          },
          errMessage: errMessage || ("The text is too short, minimum length is " + length)
        };
      },
      maxLength: function(length, errMessage) {
        return {
          isValid: function(val) {
            return val.toString().trim().length <= length;
          },
          errMessage: errMessage || ("The text is too long, maximum length is " + length)
        };
      },
      betweenLength: function(minLength, maxLength, errMessage) {
        return {
          isValid: function(val) {
            var valLength;
            valLength = val.toString().trim().length;
            return valLength >= minLength && valLength <= maxLength;
          },
          errMessage: errMessage || ("The text must have length between " + minLength + " and " + maxLength)
        };
      },
      numeric: function(errMessage) {
        return {
          isValid: function(val) {
            return $.isNumeric(val);
          },
          errMessage: errMessage || 'Field accepts only numeric values'
        };
      },
      min: function(value, errMessage) {
        return {
          isValid: function(val) {
            val = parseInt(val, 10);
            return val >= value;
          },
          errMessage: errMessage || ("Minimum value is " + value)
        };
      },
      max: function(value, errMessage) {
        return {
          isValid: function(val) {
            val = parseInt(val, 10);
            return val <= value;
          },
          errMessage: errMessage || ("Maximum value is " + value)
        };
      },
      between: function(min, max, errMessage) {
        return {
          isValid: function(val) {
            val = parseInt(val, 10);
            return val >= min && val <= max;
          },
          errMessage: errMessage || ("The value must be between " + min + " and " + max)
        };
      },
      match: function(field, errMessage) {
        if (typeof field === 'string') {
          field = $(":input[name='" + field + "']");
        }
        return {
          isValid: function(val) {
            return field.val() === val;
          },
          errMessage: errMessage || ['Field does not match with field', field.attr('name')].join(' ')
        };
      }
    };
    Eim.Slider = function(_p) {
      return _p = {
        targets: $('#images .item, #descriptions .item'),
        triggers: $('#controls a'),
        targetActiveClass: 'active',
        triggerActiveClass: 'active',
        sliderType: 'numeric',
        needCss: false,
        needBuildTriggersHtml: false
      };
    };
    Eim.sendMessage = function(message, title) {};
    Eim.improveInputFile = function(obj) {
      return obj = obj || $('input:file');
    };
    /*
        Placeholder (for IE only)
        @param callback set a callback if you need to validate your form fields,
               it will be triggered if form has fields with value == placeholder
               callback(fieldsNamesWithErrors, submittedForm)
    */

    Eim.placeholder = function(callback) {
      var errors, forms, inputs, submited, valueEqualsPlaceholder;
      if (navigator.appName === 'Microsoft Internet Explorer') {
        submited = {};
        inputs = $(':input[placeholder]');
        forms = $('form');
        errors = [];
        valueEqualsPlaceholder = function(element) {
          return element.val() === element.attr('placeholder');
        };
        inputs.each(function() {
          var _this;
          _this = $(this);
          return _this.val(_this.attr('placeholder'));
        }).focus(function() {
          var _this;
          _this = $(this);
          if (valueEqualsPlaceholder(_this)) {
            return _this.val('');
          }
        }).blur(function() {
          var _this;
          _this = $(this);
          if (!_this.val()) {
            return _this.val(_this.attr('placeholder'));
          }
        });
        if (typeof callback === 'function') {
          return forms.submit(function(e) {
            var i, that, _inputs;
            errors = [];
            that = $(this);
            i = that.index(forms);
            _inputs = that.find(':input[placeholder]');
            if (!submited[i]) {
              e.preventDefault();
              submited[i] = true;
              _inputs.each(function() {
                var _this;
                _this = $(this);
                if (valueEqualsPlaceholder(_this)) {
                  return errors.push(_this);
                }
              });
              if (errors.length) {
                submited[i] = false;
              }
              return callback(errors, that);
            }
          });
        }
      }
    };
    Form = function(params) {
      var blurTarget, blurType, formErrors, formFields, i, _blurAio, _blurEach, _fn, _onBlurTarget, _validateField, _validateForm,
        _this = this;
      formFields = params.fields;
      formErrors = {};
      _this = this;
      /*
              for i of formFields
                  if @element?
                      formFields[i].element = @element.find("input[name='#{i}']")
                      if ! formFields[i].element
                          throw "Fields must have it's own name: #{i}"
      */

      _validateField = function(fieldName, callback) {
        var err, field, fieldValue, i, validators;
        _this.clearErrors(fieldName);
        field = formFields[fieldName];
        fieldValue = field.value;
        validators = field.validators;
        err = false;
        if (validators.hasOwnProperty('isValid')) {
          if (!validators.isValid(fieldValue)) {
            err = validators.errMessage;
            _this.addError(fieldName, err);
            callback(err);
          }
        } else if (validators.length) {
          for (i in validators) {
            if (!field.hasError) {
              if (!validators[i].isValid(fieldValue)) {
                err = validators[i].errMessage;
                _this.addError(fieldName, err);
                callback(err);
              }
            }
          }
        }
        if (!err) {
          return callback();
        }
      };
      _validateForm = function(callback) {
        var error, i;
        error = false;
        for (i in formFields) {
          _validateField(i, function(err) {
            if (err) {
              return error = true;
            }
          });
        }
        return callback(error);
      };
      this.element = params.form;
      this.fields = function(name) {
        return (name && formFields[name]) || formFields;
      };
      this.bind = function(data) {
        var i;
        for (i in data) {
          if (formFields.hasOwnProperty(i)) {
            formFields[i].value = data[i];
          }
        }
        return this;
      };
      this.errors = formErrors;
      this.addError = function(fieldName, error) {
        formErrors[fieldName] = error;
        formFields[fieldName].hasError = true;
        return formFields[fieldName].error = error;
      };
      this.hasErrors = function() {
        var i;
        for (i in formFields) {
          if (formFields[i].hasError) {
            return true;
          }
        }
        return false;
      };
      this.clearErrors = function(fieldName) {
        formErrors[fieldName] = void 0;
        formFields[fieldName].hasError = void 0;
        return formFields[fieldName].error = void 0;
      };
      this.validate = function(fieldName, callback) {
        if (typeof fieldName === 'function') {
          callback = fieldName;
          _validateForm(callback);
        } else if (typeof fieldName === 'string') {
          _validateField(fieldName, callback);
        }
        return this;
      };
      blurType = params.blurType;
      _onBlurTarget = function(field, form) {
        if (blurType === 'each') {
          return field.next('.field-error');
        } else {
          return $('#form-errors');
        }
      };
      _blurEach = function(error, target, field, form) {
        return target.html(error || '');
      };
      _blurAio = function(err, target, field, form) {
        var error, message, name;
        name = field.attr('name');
        error = $("#field-error-" + name);
        if (err) {
          message = "" + name + ": " + err;
          if (error.length) {
            if (message !== error.html()) {
              return error.html(message);
            }
          } else {
            message = "<p id='field-error-" + name + "'>" + message + "</p>";
            return target.append(message);
          }
        } else if (error.length) {
          return error.html('');
        }
      };
      if (params.fieldBlur === true) {
        blurTarget = params.onBlurTarget;
        if (typeof blurTarget !== 'function') {
          blurTarget = _onBlurTarget;
        }
        if ((blurType != null) && blurType !== 'each') {
          _this.element.before('<div id="form-errors"></div>');
        }
        _fn = function(i) {
          var field;
          field = _this.element.find(":input[name='" + i + "']");
          if ((blurType != null) && blurType === 'each') {
            field.after('<span class="field-error"></span>');
          }
          return field.blur(function(e) {
            var data;
            data = {};
            data[i] = field.val();
            _this.bind(data);
            return _this.validate(i, function(err) {
              var target;
              target = blurTarget(field, _this.element);
              if (blurType === 'each') {
                return _blurEach(err, target, field, _this.element);
              } else if (blurType === 'aio') {
                return _blurAio(err, target, field, _this.element);
              }
            });
          });
        };
        for (i in formFields) {
          _fn(i);
        }
      }
      /*
              if params.onSubmit?
                  @element.blur (e) ->
                      e.preventDefault()
                      params = @element.serialize()
                      console.log(params)
      */

      return this;
    };
    return window.Eim = Eim;
  })(window);

}).call(this);
